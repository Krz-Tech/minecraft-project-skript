# -------------------------------------------------------------------------
# Module: Krz-Combat Damage Calculator
# Author: Antigravity Agent
# Since: 2025-12-24
# Description: カスタムダメージ計算、スタッガー蓄積、フローティング表示連携
# -------------------------------------------------------------------------

options:
	PREFIX: "&c[Damage] &r"
	IMPACT_MULTIPLIER: 0.5
	DIRECT_HIT_MULTIPLIER: 1.5
	CRIT_MULTIPLIER: 1.5
	
on load:
	send "%{@PREFIX}%&aダメージ計算モジュール初期化完了" to console
	
	# -------------------------------------------------------------------------
	# Event: on damage - カスタムダメージ計算
	# -------------------------------------------------------------------------
on damage:
# Check for bypass flag (RayCast / Custom Damage)
	if metadata "krz_dmg_bypass" of victim is set:
		stop
		
		# 基礎ダメージを取得
	set {_base_damage} to final damage
	
	# ... (Existing Logic shortened/refactored? No, just keep it but check inputs)
	# For simplicity, if it IS a projectile, we assume it's the old system or an explosion.
	# The RayCast system will call a function.
	
	set {_attacker_player} to executor
	if attacker is a player:
		set {_attacker_player} to attacker
		
	if damage was caused by projectile:
		if metadata "shooter" of projectile is set:
			set {_attacker_player} to metadata "shooter" of projectile
			set {_custom_dmg} to metadata "damage" of projectile
			set {_custom_impact} to metadata "impact" of projectile
			
			if {_custom_dmg} is set:
			# Custom Calculation
				set {_final} to damage_calculate({_attacker_player}, victim, {_custom_dmg})
				display_effect_process({_attacker_player}, victim, {_final}, {_custom_impact})
				set damage to {_final}
				
				# -------------------------------------------------------------------------
				# Function: damage_execute (For RayCast)
				# -------------------------------------------------------------------------
function damage_execute(p: player, victim: entity, dmg: number, impact: number, attr: text):
# Calculate
	set {_final} to damage_calculate({_p}, {_victim}, {_dmg})
	
	# Effects (Visuals + Stagger)
	display_effect_process({_p}, {_victim}, {_final}, {_impact})
	
	# Apply Damage safely
	set metadata "krz_dmg_bypass" of {_victim} to true
	damage {_victim} by {_final}
	delete metadata "krz_dmg_bypass" of {_victim}
	
	# -------------------------------------------------------------------------
	# Helper: Calculation
	# -------------------------------------------------------------------------
function damage_calculate(attacker: player, victim: entity, base: number) :: number:
	set {_final} to {_base}
	
	# Crit (Jump)
	if {_attacker} is not on ground:
		if {_attacker} is not sprinting:
			set {_final} to {_final} * {@CRIT_MULTIPLIER}
			
			# Direct Hit (Stagger)
	if {_victim} is a player:
		if stagger_is_active({_victim}) is true:
			set {_final} to {_final} * {@DIRECT_HIT_MULTIPLIER}
			
	return {_final}
	
	# -------------------------------------------------------------------------
	# Helper: Effects & Stagger
	# -------------------------------------------------------------------------
function display_effect_process(attacker: player, victim: entity, dmg: number, impact: number):
	set {_loc} to location of {_victim}
	set {_is_crit} to false
	set {_is_dh} to false
	
	# Re-check states for visuals (redundant but safe)
	if {_attacker} is not on ground:
		if {_attacker} is not sprinting:
			set {_is_crit} to true
	if {_victim} is a player:
		if stagger_is_active({_victim}) is true:
			set {_is_dh} to true
			
	if {_is_dh} is true:
		display_show_direct_hit({_loc}, {_dmg})
	else:
		display_show_damage({_loc}, {_dmg}, {_is_crit})
		
	if {_victim} is a player:
		if {_impact} is not set:
			set {_impact} to {_dmg} * {@IMPACT_MULTIPLIER}
		stagger_add_impact({_victim}, {_impact})
		display_effect_damage_glitch({_victim})
